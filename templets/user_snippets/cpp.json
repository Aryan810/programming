{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"boilerplate": {
		"prefix": "boilerplate code",
		"body": [
			"#include <iostream>\n",
			"using namespace std;\n",
			"int main(){\n",
			"\t$2",
			"\n\treturn 0;\n}"
		],
		"description": "makes boiler plate"
	},
	"cf_boiler_plate": {
		"prefix": "cf boilerplate code",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"// #pragma GCC optimize(\"Ofast,unroll-loops\")\n",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"#define int long long",
			"#define vi vector<int>",
			"#define vii vector<int>::iterator",
			"#define rep(i, n) for(int i=0;i<n;i++)",
			"#define all(c) c.begin(), c.end()",
			"#define rall(c) c.rbegin(), c.rend()",
			"template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n",
			"void solve(){\n",
			"\t$2",
			"\n}",
			"signed main(){",
			"\tios_base::sync_with_stdio(0);",
			"\tcin.tie(0); cout.tie(0);\n",
			"\tint t;",
			"\tcin >> t;\n",
			"\twhile(t--){\n",
			"\t\tsolve();",
			"\n\t}",
			"\n\treturn 0;\n}"
		],
		"description": "makes boiler plate"
	},
	"cff_boiler_plate": {
		"prefix": "cf boilerplate code",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long int",
			"#define vi vector<int>",
			"#define vii vector<int>::iterator",
			"#define vlli vector<ll>::iterator",
			"#define vll vector<ll>\n",
			"using namespace std;\n",
			"void solve(){",
			"\n}\n",
			"int main(){",
			"\tios_base::sync_with_stdio(0);",
			"\tcin.tie(0); cout.tie(0);\n",
			"\tint t;",
			"\tcin >> t;\n",
			"\twhile(t--){\n",
			"\t\t$2",
			"\nsolve();\n",
			"\n\t}",
			"\n\treturn 0;\n}"
		],
		"description": "makes boiler plate"
	},
	"binary_exp_rec": {
		"prefix": "bexpr",
		"body": [
			"int binexpr(int a, int b){",
			"\tif (b == 0){",
			"\t\treturn 1;",
			"\t}",
			"\tint x = bexpr(a, b >> 1);",
			"\tif (b%2 == 0){",
			"\t\treturn x*x;",
			"\t}else{",
			"\t\treturn a*x*x;",
			"\t}\n",
			"}"
		],
		"description": "recursive binary exponentiation"
	},
	"binary_exp_iter": {
		"prefix": "bexpi",
		"body": [
			"int binexpiter(int a, int b){",
			"\tint ans = 1;",
			"\twhile (b){",
			"\t\tif (b&1){",
			"\t\t\tans = ans * a;",
			"\t\t}",
			"\t\ta = a * a;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
		],
		"description": "iterative binary exponentiation"
	},
	"custom_hash_for_unordered_map": {
		"prefix": "custom_hash_um",
		"body": [
			"struct custom_hash {",
			"\tstatic uint64_t splitmix64(uint64_t x) {",
			"\t\tx += 0x9e3779b97f4a7c15;",
			"\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"\t\treturn x ^ (x >> 31);",
			"\t}",
			"\tsize_t operator()(uint64_t x) const {",
			"\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"\t\treturn splitmix64(x + FIXED_RANDOM);",
			"\t}",
			"};",
		],
		"description": "custom hash for unordered map"
	},
	"modular_binary_exp_iter": {
		"prefix": "mbexpi",
		"body": [
			"int binexpiter(int a, int b){",
			"\tint ans = 1;",
			"\twhile (b){",
			"\t\tif (b&1){",
			"\t\t\tans = (ans * a)%M;",
			"\t\t}",
			"\t\ta = (a * a)%M;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
		],
		"description": "iterative binary exponentiation"
	},
	"mydsu": {
		"prefix": "dsu",
		"body": [
			"struct dsu{",
			"    int n;",
			"    vector<int> parent, set_size;",
			"    dsu(int n){",
			"        this->n = n;",
			"        parent.resize(n);",
			"        set_size.resize(n);",
			"        for (int i = 0; i < n; i++){",
			"            parent[i] = i;",
			"            set_size[i] = 1;",
			"        }",
			"    }",
			"    int find(int v){",
			"        if(v == parent[v]) return v;",
			"        return parent [v] = find (parent [v]);",
			"    }",
			"    void set_union (int a, int b){",
			"        a = find(a);",
			"        b = find (b);",
			"        if(a != b){",
			"            if(set_size[a] < set_size [b]){",
			"                swap (a, b) ;",
			"            }",
			"            parent[b] = a;",
			"            set_size[a] += set_size[b];",
			"        }   ",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (DSU) structure"
	},
	"my_custom_hash": {
		"prefix": "customhash",
		"body": [
			"struct custom_hash {",
			"    static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};"
		],
		"description": "Custom hash struct for unordered_map"
	},
	"bsqrt": {
		"prefix": "bsqrt",
		"body": [
			"int bsqrt(int n){",
			"    if (n == 0){",
			"        return 0;",
			"    }else if (n == 1){",
			"        return 1;",
			"    }",
			"    int l = 2;",
			"    int h = n;",
			"    while (h-l>1){",
			"        int mid = (h + l)/2;",
			"        if (mid*mid == n){",
			"            return mid;",
			"        }else if (mid*mid < n){",
			"            l = mid;",
			"        }else{",
			"            h = mid - 1;",
			"        }",
			"    }",
			"    if (h*h <= n){",
			"        return h;",
			"    }else{",
			"        return l;",
			"    }",
			"}"
		],
		"description": "Binary search integer square root"
	},
	"graph": {
		"prefix": "graph",
		"body": [
			"vector<vector<int> > graph;",
		],
		"description": "Graph"
	},
	"mint_modular": {
		"prefix": "mint",
		"body": [
			"template<typename T>",
			"T euclid(T x, T y, T &k, T &l) {",
			"\tif (x < 0) {",
			"\t\tT g = euclid(-x, y, k, l);",
			"\t\tk = -k;",
			"\t\treturn g;",
			"\t}",
			"\tif (y < 0) {",
			"\t\tT g = euclid(x, -y, k, l);",
			"\t\tl = -l;",
			"\t\treturn g;",
			"\t}",
			"\tif (y == 0) {",
			"\t\tk = 1;",
			"\t\tl = 0;",
			"\t\treturn x;",
			"\t}",
			"\tT g = euclid(y, x % y, l, k);",
			"\tl -= k * (x / y);",
			"\treturn g;",
			"}",
			"",
			"uint MOD = 998244353;",
			"struct Mint {",
			"\tuint x;",
			"",
			"\tMint() : x(0) {}",
			"\tMint(ll _x) {",
			"\t\t_x %= MOD;",
			"\t\tif (_x < 0) _x += MOD;",
			"\t\tx = _x;",
			"\t}",
			"",
			"\tMint& operator += (const Mint &a) {",
			"\t\tx += a.x;",
			"\t\tif (x >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tMint& operator -= (const Mint &a) {",
			"\t\tx += MOD - a.x;",
			"\t\tif (x >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tMint& operator *= (const Mint &a) {",
			"\t\tx = (ull)x * a.x % MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tMint pow(ll pw) const {",
			"\t\tMint res = 1;",
			"\t\tMint cur = *this;",
			"\t\twhile(pw) {",
			"\t\t\tif (pw & 1) res *= cur;",
			"\t\t\tcur *= cur;",
			"\t\t\tpw >>= 1;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\tMint inv() const {",
			"\t\tll g, k, l;",
			"\t\tg = euclid<ll>(x, MOD, k, l);",
			"\t\tassert(g == 1);",
			"\t\tk %= MOD;",
			"\t\tif (k < 0) k += MOD;",
			"\t\treturn k;",
			"\t}",
			"\tMint& operator /= (const Mint &a) {",
			"\t\treturn *this *= a.inv();",
			"\t}",
			"\tMint operator + (const Mint &a) const {",
			"\t\treturn Mint(*this) += a;",
			"\t}",
			"\tMint operator - (const Mint &a) const {",
			"\t\treturn Mint(*this) -= a;",
			"\t}",
			"\tMint operator * (const Mint &a) const {",
			"\t\treturn Mint(*this) *= a;",
			"\t}",
			"\tMint operator / (const Mint &a) const {",
			"\t\treturn Mint(*this) /= a;",
			"\t}",
			"",
			"\tbool operator == (const Mint &a) const {",
			"\t\treturn x == a.x;",
			"\t}",
			"\tbool operator != (const Mint &a) const {",
			"\t\treturn x != a.x;",
			"\t}",
			"\tbool operator < (const Mint &a) const {",
			"\t\treturn x < a.x;",
			"\t}",
			"};"
		],
		"description": "Modular arithmetic structure with 998244353 modulo"
	},
	"graphinp": {
		"prefix": "graphinp",
		"body": [
			"for (int i=0;i<m;i++){",
			"\tint x, y;",
			"\tcin >> x >> y;",
			"\tgraph[x].push_back(y);",
			"\tgraph[y].push_back(x);",
			"}"
		],
		"description": "Graph input reading code"
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"class segtree{",
			"    public:",
			"        int n;",
			"        vi arr;",
			"        vi leafs;",
			"        vi val;",
			"        int (*comp)(int a, int b) = [](int a, int b){return a+b;};",
			"        int DEF = 0;",
			"        int make(int v, int l, int r){",
			"            if (l < r){",
			"                val[v] = comp(make(2*v+1, l, (l+r)/2), make(2*v + 2, (l+r)/2 + 1, r));",
			"                return val[v];",
			"            }else if (l < n && l == r){",
			"                leafs[l] = v;",
			"                val[v] = arr[l];",
			"                return val[v];",
			"            }else{",
			"                return DEF;",
			"            }",
			"        }",
			"        void update(int i, int newval){",
			"            int j = leafs[i];",
			"            val[j] = newval;",
			"            while (j != 0){",
			"                int k;",
			"                int par;",
			"                if (j&1){",
			"                    k = j + 1;",
			"                    par = j/2;",
			"                }else{",
			"                    k = j - 1;",
			"                    par = j/2 - 1;",
			"                }",
			"                val[par] = comp(val[j], val[k]);",
			"                j = par;",
			"            }",
			"        }",
			"    ",
			"        int finder(int j, int l, int r, int ql, int qr){",
			"            if (l >= ql && r <= qr){",
			"                return val[j];",
			"            }else if (l > qr || r < ql){",
			"                return DEF;",
			"            }else{",
			"                return comp(finder(2*j+1, l, (l+r)/2, ql, qr), finder(2*j+2, (l+r)/2+1, r, ql, qr));",
			"            }",
			"        }",
			"    ",
			"        int find(int l, int r){",
			"            return finder(0, 0, arr.size()-1, l, r);",
			"        }",
			"",
			"        segtree(int n, vi arr, int default_val=0, int (*comp)(int a, int b)=NULL){",
			"            int sz = 0;",
			"            int x = 1;",
			"            if (comp){this->comp = comp;}",
			"            while (1){",
			"                sz += x;",
			"                if (x >= n){break;}",
			"                x *= 2;",
			"            }",
			"            this->n = n;",
			"            this->DEF = default_val;",
			"            this->arr = arr;",
			"            this->leafs.resize(sz);",
			"            this->val.assign(sz, this->DEF);",
			"            make(0, 0, arr.size()-1);",
			"        }",
			"};"
		],
		"description": "Segment tree implementation with customizable operation"
	}
}